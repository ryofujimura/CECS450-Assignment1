<!DOCTYPE html>
<html>
<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      z-index: 1000;
    }
  </style>
</head>
<body>
<div id="chart"></div>

<script>
const svg = d3.select("#chart")
  .append("svg")
  .attr("width", 1000)
  .attr("height", 600);

// Create tooltip
const tooltip = d3.select("body").append("div")
  .attr("class", "tooltip");

// Load actual CSV data
fetch('Motor_Vehicle_Collisions_2020-2024.csv')
  .then(response => response.text())
  .then(text => {
    const csvData = d3.csvParse(text);
    
    // Extract unique vehicle types and months from actual data
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    // Get vehicle types from CSV (limit to most common ones for readability)
    const vehicleTypeCounts = d3.rollup(csvData, v => v.length, d => d['VEHICLE TYPE CODE 1']);
    const sortedVehicleTypes = Array.from(vehicleTypeCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 8) // Top 8 most common vehicle types
      .map(d => d[0]);
    
    // Process real collision data
    const monthlyData = [];
    csvData.forEach(d => {
      const monthNum = parseInt(d['MONTH']);
      if (!isNaN(monthNum) && monthNum >= 1 && monthNum <= 12) {
        monthlyData.push({
          month: monthNum,
          monthName: months[monthNum - 1],
          vehicleType: d['VEHICLE TYPE CODE 1'],
          year: parseInt(d['YEAR']),
          count: 1
        });
      }
    });
    
    // Aggregate data by vehicle type and month (sum across years)
    const aggregatedData = d3.rollup(
      monthlyData,
      v => v.length, // Count collisions
      d => d.vehicleType,
      d => d.month
    );
    
    const processedData = [];
    sortedVehicleTypes.forEach(vehicleType => {
      const vehicleData = [];
      months.forEach((month, i) => {
        const count = aggregatedData.get(vehicleType)?.get(i + 1) || 0;
        vehicleData.push({ month: i + 1, monthName: month, count: count });
      });
      processedData.push({
        vehicleType: vehicleType,
        values: vehicleData
      });
    });
    
    initializeChart();
    
    function initializeChart() {
      // Scales
      const xScale = d3.scaleLinear().domain([1, 12]).range([250, 600]);
      
      // Y-axis with zoom capability
      const maxCollisions = d3.max(processedData.flatMap(d => d.values), v => v.count);
      // Initialize with 3x zoom (middle position)
      let yScale = d3.scaleLinear().domain([0, maxCollisions / 3]).range([500, 100]);

      // Color scale
      const color = d3.scaleOrdinal(d3.schemeCategory10).domain(sortedVehicleTypes);

      // Add axes
      const xAxis = svg.append("g")
        .attr("transform", "translate(0,500)")
        .call(d3.axisBottom(xScale).tickFormat((d,i) => months[i]));

      const yAxis = svg.append("g")
        .attr("transform", "translate(250,0)")
        .call(d3.axisLeft(yScale));

      // Title
      svg.append("text")
        .attr("x", 425)
        .attr("y", 40)
        .attr("text-anchor", "middle")
        .attr("font-size", "18px")
        .attr("font-weight", "bold")
        .text("Monthly Collision Patterns (2020-2024 Total) by Vehicle Type");

      // Labels
      svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 30)
        .attr("x", -300)
        .attr("text-anchor", "middle")
        .text("Collision Count");

      svg.append("text")
        .attr("x", 425)
        .attr("y", 580)
        .attr("text-anchor", "middle")
        .text("Month");

      // Add zoom slider
      const zoomControls = svg.append("g").attr("transform", "translate(680, 40)");
      
      // Zoom slider background
      zoomControls.append("rect")
        .attr("width", 280)
        .attr("height", 50)
        .attr("fill", "white")
        .attr("stroke", "gray")
        .attr("stroke-width", "1px");
      
      // Zoom slider title
      zoomControls.append("text")
        .attr("x", 10)
        .attr("y", 15)
        .attr("font-size", "10px")
        .attr("font-weight", "bold")
        .text("Y-Axis Zoom");
      
      // Zoom slider track
      const sliderWidth = 260;
      const sliderHeight = 6;
      const sliderX = 10;
      const sliderY = 30;
      
      zoomControls.append("rect")
        .attr("x", sliderX)
        .attr("y", sliderY)
        .attr("width", sliderWidth)
        .attr("height", sliderHeight)
        .attr("fill", "#ddd");
      
      // Zoom slider handle
      const zoomHandle = zoomControls.append("circle")
        .attr("cx", sliderX + sliderWidth * 0.5) // Start at middle (50% position = 3x zoom)
        .attr("cy", sliderY + sliderHeight/2)
        .attr("r", 8)
        .attr("fill", "#333")
        .attr("stroke", "white")
        .attr("stroke-width", 2)
        .style("cursor", "pointer")
        .call(d3.drag()
          .on("drag", function(event) {
            const newX = Math.max(sliderX, Math.min(sliderX + sliderWidth, event.x));
            const normalizedPos = (newX - sliderX) / sliderWidth;
            zoomHandle.attr("cx", newX);
            
            // Update Y scale (position 0 = full view, 1 = 5x zoom)
            const zoomFactor = 1 + normalizedPos * 4; // 1x to 5x zoom
            const newMax = maxCollisions / zoomFactor;
            yScale = d3.scaleLinear().domain([0, newMax]).range([500, 100]);
            
            // Update chart elements
            updateChartScale();
          }));
      
      // Label for zoom level
      const zoomLabel = zoomControls.append("text")
        .attr("x", 10)
        .attr("y", 45)
        .attr("font-size", "8px")
        .attr("fill", "#666")
        .text("3.0x");

      // Line generator
      const line = d3.line()
        .x(d => xScale(d.month))
        .y(d => yScale(d.count))
        .curve(d3.curveMonotoneX);

      // Create lines for each vehicle type with animation and hover effects
      const lineGroups = [];
      processedData.forEach((vehicleGroup, index) => {
        setTimeout(() => {
          const group = svg.append("g").attr("class", `vehicle-group-${index}`);
          
          const path = group.append("path")
            .datum(vehicleGroup.values)
            .attr("d", line)
            .attr("stroke", color(vehicleGroup.vehicleType))
            .attr("stroke-width", 3)
            .attr("fill", "none")
            .style("opacity", 0)
            .style("cursor", "pointer")
            .on("mouseover", function() {
              highlightVehicle(vehicleGroup.vehicleType);
            })
            .on("mouseout", function() {
              resetHighlights();
            });
          
          lineGroups.push(group);

          // Animate the line drawing
          const totalLength = path.node().getTotalLength();
          path
            .attr("stroke-dasharray", `${totalLength} ${totalLength}`)
            .attr("stroke-dashoffset", totalLength)
            .style("opacity", 1)
            .transition()
            .duration(1500)
            .delay(index * 200)
            .attr("stroke-dashoffset", 0);

          // Add interactive circles for each data point
          vehicleGroup.values.forEach((point, pointIndex) => {
            setTimeout(() => {
              group.append("circle")
                .attr("cx", xScale(point.month))
                .attr("cy", yScale(point.count))
                .attr("r", 0)
                .attr("fill", color(vehicleGroup.vehicleType))
                .transition()
                .duration(300)
                .delay(1500 + index * 200 + pointIndex * 100)
                .attr("r", 5)
                .style("cursor", "pointer")
                .on("mouseover", function(event) {
                  highlightVehicle(vehicleGroup.vehicleType);
                  tooltip.transition().duration(200).style("opacity", 1);
                  tooltip.html(`
                    <strong>${vehicleGroup.vehicleType}</strong><br/>
                    Month: ${point.monthName}<br/>
                    Collisions: ${point.count}
                  `)
                  .style("left", (event.pageX + 10) + "px")
                  .style("top", (event.pageY - 30) + "px");
                })
                .on("mousemove", function(event) {
                  tooltip
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 30) + "px");
                })
                .on("mouseout", function() {
                  resetHighlights();
                  tooltip.transition().duration(200).style("opacity", 0);
                });
            }, 0);
          });

        }, index * 200);
      });

      // Left Legend - Fibonacci hierarchy design
      const legend = svg.append("g").attr("transform", "translate(20, 120)");
      legend.append("rect").attr("width", 200).attr("height", 360).attr("fill", "white").attr("stroke", "gray").attr("stroke-width", "1px");

      // Main title with large hierarchy
      legend.append("text")
        .attr("x", 10)
        .attr("y", 30)
        .attr("font-size", "21px")
        .attr("font-weight", "bold")
        .text("Vehicle Types");

      // Subtitle with medium hierarchy  
      legend.append("text")
        .attr("x", 10)
        .attr("y", 55)
        .attr("font-size", "13px")
        .attr("fill", "#666")
        .text("Click to highlight");

      sortedVehicleTypes.forEach((vehicleType, i) => {
        const legendGroup = legend.append("g")
          .attr("class", `legend-item-${i}`)
          .style("cursor", "pointer");

        // Line indicator
        legendGroup.append("line")
          .attr("x1", 10)
          .attr("y1", 75 + i * 30)
          .attr("x2", 25)
          .attr("y2", 75 + i * 30)
          .attr("stroke", color(vehicleType))
          .attr("stroke-width", "3px");

        // Vehicle type name with body hierarchy
        legendGroup.append("text")
          .attr("x", 35)
          .attr("y", 80 + i * 30)
          .attr("font-size", "13px")
          .attr("font-weight", "normal")
          .text(vehicleType);

        // Hover area
        legendGroup.append("rect")
          .attr("x", 5)
          .attr("y", 65 + i * 30)
          .attr("width", 190)
          .attr("height", 30)
          .attr("fill", "transparent")
          .on("mouseover", function() {
            highlightVehicle(vehicleType);
          })
          .on("mouseout", function() {
            resetHighlights();
          });
      });

      // Right Info Box - Fibonacci hierarchy design
      const infoBox = svg.append("g").attr("transform", "translate(780, 120)");
      const infoRect = infoBox.append("rect")
        .attr("width", 200)
        .attr("height", 360)
        .attr("fill", "white")
        .attr("stroke", "gray")
        .attr("stroke-width", "1px");

      // Main title with large hierarchy
      const infoTitle = infoBox.append("text")
        .attr("x", 10)
        .attr("y", 30)
        .attr("font-size", "21px")
        .attr("font-weight", "bold")
        .text("Collision Stats");

      // Subtitle with medium hierarchy
      infoBox.append("text")
        .attr("x", 10)
        .attr("y", 55)
        .attr("font-size", "13px")
        .attr("fill", "#666")
        .text("Sum Across 5 Years");

      // Main content area
      const infoContent = infoBox.append("text")
        .attr("x", 10)
        .attr("y", 85)
        .attr("font-size", "13px")
        .attr("font-weight", "bold")
        .text("");

      // Details area with small hierarchy
      const infoDetails = infoBox.append("text")
        .attr("x", 10)
        .attr("y", 110)
        .attr("font-size", "10px")
        .attr("fill", "#666")
        .text("");

      // Functions for highlighting
      function highlightVehicle(vehicleType) {
        const index = sortedVehicleTypes.indexOf(vehicleType);
        d3.select(`.vehicle-group-${index}`).style("opacity", 1);
        lineGroups.forEach((group, groupIndex) => {
          if (groupIndex !== index) {
            group.style("opacity", 0.2);
          }
        });
        
        // Update info box with vehicle-specific data
        const vehicleData = processedData.find(d => d.vehicleType === vehicleType);
        const totalCollisions = d3.sum(vehicleData.values, v => v.count);
        const avgCollisions = Math.round(totalCollisions / 12);
        const peakMonth = vehicleData.values.reduce((max, curr) => curr.count > max.count ? curr : max);
        
        infoContent.text(`${totalCollisions} total`);
        infoDetails.text(`Avg/month: ${avgCollisions} collisions\nPeak: ${peakMonth.monthName} (${peakMonth.count})`);
      }

      function resetHighlights() {
        lineGroups.forEach(group => {
          group.style("opacity", 1);
        });
        
        // Show overview of all vehicles with proper formatting
        const totalCounts = [];
        processedData.forEach(vehicleGroup => {
          const totalCollisions = d3.sum(vehicleGroup.values, v => v.count);
          totalCounts.push(`${vehicleGroup.vehicleType}: ${totalCollisions}`);
        });
        
        infoContent.text("All Vehicle Types (Total)");
        
        // Format vehicle list with each vehicle on separate line
        let text = "";
        totalCounts.forEach(count => {
          text += `${count}\n`;
        });
        
        infoDetails.text(text);
      }

      // Function to update chart scale when zooming
      function updateChartScale() {
        // Update Y-axis
        yAxis.transition().duration(200).call(d3.axisLeft(yScale));
        
        // Update all lines
        lineGroups.forEach((group, index) => {
          const vehicleGroup = processedData[index];
          group.selectAll("path")
            .transition()
            .duration(200)
            .attr("d", d3.line()
              .x(d => xScale(d.month))
              .y(d => yScale(d.count))
              .curve(d3.curveMonotoneX)
              (vehicleGroup.values));
          
          // Update all circles by reusing original data
          group.selectAll("circle")
            .transition()
            .duration(200)
            .attr("cy", function(d, i) {
              const point = vehicleGroup.values[i];
              return yScale(point ? point.count : d.count);
            });
        });
        
        // Update zoom label
        const currentZoomFactor = maxCollisions / yScale.domain()[1];
        zoomLabel.text(`${currentZoomFactor.toFixed(1)}x`);
      }

      // Initialize overview
      resetHighlights();
    }
  })
  .catch(error => {
    console.error('Error loading CSV:', error);
    svg.append("text")
      .attr("x", 500)
      .attr("y", 300)
      .attr("text-anchor", "middle")
      .text("Error loading collision data");
  });

</script>
</body>
</html>